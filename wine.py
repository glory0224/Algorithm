# 백준 2156번 포도주 시식 문제 

# 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
# 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

# 포도주의 양을 담은 리스트 


n = int(input())
# 자리수 맞춰주기 위한 0 추가
w = [0]

# 실제 인덱스 1~ 6 for문 돌면서 n번째 포도주의 양을 넣는다. 
for i in range(n):
    w.append(int(input()))

# dp도 마찬가지로 인덱스를 맞춰주기 위해서 0을 먼저 넣어준다.
dp = [0]
dp.append(w[1])
# 포도주가 0개인 경우는 예외 처리 무조건 1개 이상부터 받을 수 있게 if문 사용하여 dp[2]에 값을 넣는다. 
if n > 1:
    dp.append(w[1] + w[2])

# 3부터는 연속으로 3잔을 마실 수 없다
for i in range(3, n + 1):
    # ex) w[3] 
    # dp[2] = 위에서 w[1] + w[2] = 16 (자신이 3번째 수로 온 경우이기 때문에 자신의 값은 더할 수 없다.)
    # dp[0] + w[2] + w[3] = 0 + 10 + 13 = 23
    # dp[1] + w[3] = 6 + 13 = 19 -> 현재 i가 3일때 dp[1]은 w[0] + w[1]의 값을 더한 최대 값이 저장 되어 있기 때문에 w[2]의 인덱스를 건너 뛴 w[3]을 더해준다. 
    # 중에서 최대 값을 dp[3]에 넣는다.
    # ex) w[4]
    # dp[3] = 23
    # dp[1] + w[3] + w[4] = 6 + 13 + 9 = 28
    # dp[2] + w[4] = 16 + 9 = 25
    # 중에서 최대 값을 dp[4]에 넣는다.
    # 이런식으로 ....인덱스가 증가하면서 최대값이 계속 갱신되어 배열에 추가     
    dp.append(max(dp[i - 1], dp[i - 3] + w[i - 1] + w[i], dp[i - 2] + w[i]))
# 가장 위에 쌓인 값이 최대 값이기 때문에 출력해준다. 
print(dp[n])



