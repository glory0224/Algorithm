# 백준 10844번 쉬운 계단 수 

n = int(input())

# 뒤의 자리가 1 ~ 9 까지 올 배열과 N이 1부터 100까지 온다는 조건의 배열을 dp 2차원 배열로 생성 
dp = [[0 for i in range(10)] for j in range(101)]

# 이때 1부터 시작한다고 문제에서 줬지만 0으로는 시작할 수 없다고 했기 때문에 dp[1][0] = 0 초기화
for i in range(1, 10):
    dp[1][i] = 1 # dp[i = 자리수][j=올수 있는 수] -> 1의 자리수는 어차피 1개씩 밖에 못오기 때문에 1로 채워줌

for i in range(2, n + 1): # 1자리수는 이미 1로 초기화 했기 때문에 2 자리수부터 n 길이 자리수까지 범위 지정 
    for j in range(10):
        
        # 0으로 끝나는 수는 앞의 1밖에 오지 못하기 때문에 (자리수 -1) 오른쪽 대각선(1로 끝나는 수) 의 경우의 수와 동일 
        if j == 0:
            dp[i][j] = dp[i-1][1]
            
        # 9로 끝나는 수는 앞의 8밖에 오지 못하기 때문에 (자리수 -1) 왼쪽 대각선(8로 끝나는 수) 의 경우의 수와 동일 
        elif j == 9:
            dp[i][j] = dp[i-1][8]
            
        # 마지막 끝나는 수가 2 ~ 8 사이인 경우 
        # -> [자리수 -1]['마지막에 올 수 있는 수 - 1'의 경우의 수] -> 2차원 표로 볼 때 왼쪽 대각선
        # -> [자리수 -1]['마지막에 올 수 있는 수 + 1'의 경우의 수] -> 2차원 표로 볼 때 오른쪽 대각선
        # 위의 경우의 수를 모두 더하면 각 자리수마다 올 수 있는 경우의 수 출력 가능(규칙성)
        else:
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]
            
print(sum(dp[n]) % 1000000000)
