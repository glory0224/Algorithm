# 백준 1931번 회의실 배정 

"""
아이디어 

- 회의의 시작 시간과 끝나는 시간이 같을 수 있다는 조건 
ex)
2
3 3
3 3

-> 1이 아닌 2가 나와야한다.

- 가장 많은 회의 수를 알기 위해서 빨리 끝나는 회의 순서대로 정렬한다.
ex)
4
0 10
3 4
2 3
1 2

-> 회의의 순서대로 하면 (0 10) 1번 회의 가능, 끝나는 시간으로 정렬하면 
(1 2) , (2 3), (3 4) 총 3번의 회의가 가능하기 때문이다.

- 끝나는 시간이 같은 경우 빨리 시작하는 순서대로 정렬
ex)
2
2 2
1 2

-> 처음 들어온 (2 2)가 회의를 하기 때문에 횟수가 1번으로 나오지만 정렬을 통해 (1 2)가 먼저 선택된다면
(2 2)도 선택 가능해져서 가능한 회의가 2번이 되기 때문이다.

즉 , 정렬은 끝나는 시간의 오름차순, 시작하는 시간의 오름차순을 해준다.
"""

import sys


input = int(sys.stdin.readline())

time = [[0]*2 for _ in range(input)] # time[0] * 2 = 시작 시간과 끝나는 시간을 각각 받기 위한 배열 


# 입력 값을 map으로 받으면서 이미 시작 시간은 오름차순 정렬이 되어 있다. 
for i in range(input):
    s, e = map(int, sys.stdin.readline().split())
    time[i][0] = s
    time[i][1] = e
    
# sort의 key 속성 lamda를 이용해서 끝나는 시간의 오름차순 정렬을 해준다.
# 이때 어차피 입력 받을 때 시작 시간과 끝나는 시간 모두 오름차순 정렬이 되어 있기 때문에 똑같아 보이지만 꼭 정렬해야한다.
time.sort(key= lambda x : (x[1], x[0]))



cnt = 1
end_time = time[0][1]

# 시작 값 포함해서 cnt를 올려주기 위해 1부터 시작 
for i in range(1, input):
    if time[i][0] >= end_time:
        cnt += 1
        end_time = time[i][1]
        
print(cnt)

