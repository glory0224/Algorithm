# 백준 1201번 NMK : 가장 긴 증가하는 부분 수열과 가장 긴 감소하는 부분 수열 
# https://sujeng97.tistory.com/9

"""
 주어지는 수 : N
 최대 부분 증가 수열의 길이 : M
 최대 부분 감소 수열의 길이 : K
 
 아이디어
 
 - N은 M + K -1 이상이어야 한다. 
 -> 증가, 감소 수열은 한번씩 나와야 하기 때문에 M + K가 가능하고 1을 빼는 이유는 두 수열이 하나의 숫자를 공유하기 때문
 ex) 2 1 4 : 감소와 증가가 한번씩 나타난다. 이때 1은 공유된다. 
 
- N은 M * K 보다 작거나 같아야 한다.
ex) M =2, K = 2 일 때 이 조건을 만족하는 가장 긴 수열 [[2, 1], [4, 3]] , N = 4
만약 n이 m*k보다 크다면, 길이가 m+1인 LIS나 k+1인 LDS가 무조건 만들어지기 때문에, 답을 구할 수 없습니다.

(코드를 예제의 대입)

ex ) N = 13 , M = 5, K = 4 

A = [[4, 3, 2, 1], [6, 5], [8, 7], [10, 9], [13,12,11]]의 조건을 만족한다.
이때 LIS(Longest Increasing Subsequence)는 행의 개수인 5입니다. (2차원 배열의 각 배열 순서)
그리고 LDS(Longest Decreasing Subsequence)는 열의 최대 길이인 4입니다. (= [4, 3, 2, 1])

A = []로 두고, 먼저 K = 4 이므로 4,3,2,1을 A에 추가합니다.
그 후에 N개의 수 중에서 K개를 사용했기 때문에 N에서 K를 뺍니다.(N = 9) , 즉 9개의 수를 사용 가능합니다.
총 행의 개수 5에서 행을 이미 하나 만들었기 때문에 앞으로 만들어지는 행의 개수는 4개입니다. (M=4)
앞으로 N과 M을 0으로 만들면 됩니다. 

N//M = 9 // 4 = 2 다음으로 만들 행의 원소의 개수를 의미합니다. 
[K + 2:K] 의 수를 A에 추가합니다. 6, 5가 추가됩니다.
2개의 수를 사용했기 때문에 N = 7 이고, 1개의 행을 더 만들었기 때문에 M = 3이됩니다.
K는 +=2 연산 후 6으로 갱신

7//3 = 2이므로 A에 [k+2:k]인 8,7이 추가됩니다. 그 후 n,m,k = 5,2,8이 됩니다.
5//2 = 2이므로 A에 10,9가 추가합니다. n,m,k = 3,1,10
3//1 = 3이므로 A에 13,12,11이 추가합니다. n,m,k = 0,0,13 

"""

N, M, K = map(int, input().split())

if N < M + K - 1 or N > M * K:
    print(-1)
else:
    l = list(range(K, 0, -1))
    N -= K 
    M -= 1
    while M:
        # list.extend(iterable)는 리스트 끝에 가장 바깥쪽 iterable(반복문의 배열)의 모든 항목을 넣습니다.
        l.extend(range(K+N//M,K,-1))
        K += N//M
        N -= N//M
        M -= 1
    print(*l) #리스트 요소 한줄에 출력 
    
