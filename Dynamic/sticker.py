# 9465번 백준 스티커 문제 

t = int(input())

# 테스트 케이스 t 범위만큼 for문 돌린다. 
for i in range(t):
  # 점수를 받을 배열 선언
  s = []
  # 입력 받을 점수 길이 
  n = int(input()) 
  # 점수 입력을 두번에 나눠서 받기 위해 범위 2까지 설정하면서 2차원 배열을 생성한다.  [[50, 10, 100, 20, 40], [30, 50, 70, 10, 60]]
  for k in range(2):
    s.append(list(map(int, input().split())))


  for j in range(1, n):
    if j == 1:
    # -> 위의 값인 s[0][0]을 뜯을 경우 아래쪽과 오른쪽을 못쓴다. (원래 문제는 연결된 모든 면의 점수를 못사용한다고 했지만 초기 값으로 왼쪽 값이 없다.)
    # -> 아래 값인 s[0][1]을 뜯을 경우 위쪽과 오른쪽을 못쓴다. 
    # 따라서 아래와 같이 코드를 작성한다.
      s[0][j] += s[1][j - 1] # s[0][1] (30) += s[1][0] (10) -> 아래를 찢은 경우 
      s[1][j] += s[0][j - 1] # s[1][1] (50) += s[0][1] (50) -> 위를 찢은 경우
    
  # 2 ~ n - 1까지 
    else:
      # 아래를 찢은 경우 :  이때까지 최대 값을 더한 숫자를 저장하고 있는 왼쪽 대각선 위 숫자와 또 그 왼쪽의 숫자 두가지를 경우를 더할 수 있다. 최대값을 구하기 때문에 max 비교한 후 더해준다. 
      s[0][j] += max(s[1][j - 1], s[1][j - 2])
      # 위를 찢은 경우 :  반대로 최대 값을 저장하고 있는 왼쪽 대각선 아래와 그 왼쪽 숫자를 max로 비교한 후 더해준다. 
      s[1][j] += max(s[0][j - 1], s[0][j - 2]) 
  print(max(s[0][n - 1], s[1][n - 1])) # 다 비교 한 후에 위와 아래의 쌓인 최대 값중 가장 큰 값을 출력한다. 
 
