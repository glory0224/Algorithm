# 암호문 3

# 0 ~ 999999 사이의 수를 나열하여 만든 암호문이 있다.

# 암호문을 급히 수정해야 할 일이 발생했는데, 이 암호문은 특수 제작된 처리기로만 수정이 가능하다.

# 이 처리기는 다음과 같이 3개의 기능을 제공한다.
 
# 1. I(삽입) x, y, s : 앞에서부터 x의 위치 바로 다음에 y개의 숫자를 삽입한다. s는 덧붙일 숫자들이다.[ ex) I 3 2 123152 487651 ]

# 2. D(삭제) x, y : 앞에서부터 x의 위치 바로 다음부터 y개의 숫자를 삭제한다.[ ex) D 4 4 ]

# 3. A(추가) y, s : 암호문의 맨 뒤에 y개의 숫자를 덧붙인다. s는 덧붙일 숫자들이다. [ ex) A 2 421257 796813 ]

# 위의 규칙에 맞게 작성된 명령어를 나열하여 만든 문자열이 주어졌을 때, 암호문을 수정하고, 수정된 결과의 처음 10개 숫자를 출력하는 프로그램을 작성하여라.

# [입력]

# 첫 번째 줄 : 원본 암호문의 길이 N ( 2000 ≤ N ≤ 4000 의 정수)

# 두 번째 줄 : 원본 암호문

# 세 번째 줄 : 명령어의 개수 ( 250 ≤ M ≤ 500 의 정수)

# 네 번째 줄 : 명령어

# 위와 같은 네 줄이 한 개의 테스트 케이스이며, 총 10개의 테스트 케이스가 주어진다.

# [출력]

# #기호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 수정된 암호문의 처음 10개 항을 출력한다.

# [제약 사항]

# 실행 시간 60ms 이하

# 3198
# 801199 482510 422184 242474 876697 940126 116534 339876 247263 458098 825098 223019 514111 303365 893555 243643 601338 454353 574796 689563 658854 865075 999888 791926 506889 150144 881247 837754 384870 933366 151318 687639 496390 595628 735176 968833 750368...
# 425
# I 3186 6 111702 108909 437791 460849 808743 573893 A 6 902149 801457 885061 112389 207283 358796 A 1 989955 D 1100 5 D 613 9 D 998 1 D 2199 8 D 587 6 D 143 8 D 1945 6 I 5 1 362947 I 7 4 625354 271596 881263 415567 D 2452 10 A 6 351214 252282 334858 374262 106813 994606 I 1511 6 620092 829075 862184 856364 360195 511867 D 1320 6 A 8 871822 227120 817588 231183 650912 326064 820579 435543 D 2700 9 D 2175 9...
# 2480
# 462938 344563 399723 402947 549987 412958 420530 303429 692228 880290 950090 345253 201473 654529 200533 208289 931176 689125 751855 263503 586373 771415 616316 329388 671296 159465 930131 534966 554443 543621 857436 778109 367173 183314 320579 535313 592073...
# 486
# A 3 901476 874927 362782 I 2368 7 286743 531172 693997 463259 976783 950242 673417 I 1466 3 145128 911981 664388 A 6 297281 402815 844393 472552 109416 648820 A 7 204996 777689 213612 161950 105193 439798 213002 D 142 8 I 330 3 803653 583330 161345...

# 출력
# #1 471034 815406 542284 170257 228297 740370 785047 677617 834173 648732
# #2 364373 466241 450661 237978 437060 679163 812457 727955 262600 218437
# ...

for tc in range(1, 11):
    origin_len = int(input())
    origin = list(map(int, input().split()))
    cmd_len = int(input())
    commands = input().split()

    cmd = [] # 명령어를 튜플 형태로 변환하여 저장할 리스트

    i = 0 # while문의 index 선언

    while i < len(commands): # 명령어의 개수만큼 반복
        
        # I 에 해당하는 명령어 모음 
        if commands[i] == 'I': # 삽입 명령어의 경우
            x = int(commands[i+1]) # 삽입 위치 x
            y = int(commands[i+2]) # 삽입할 숫자 개수 y
            s = list(map(int, commands[i+3:i+3 + y])) # 3번째 인덱스부터 y에 해당하는 길이까지 리스트 형태로 저장
            cmd.append(('I', x, y, s)) # (명령어, x, y, s) 형태로 변환
            i += 3 + y # 인덱스 이동시켜 다음 명령 확인
        
        # A에 해당하는 명령어 모음
        elif commands[i] == 'A': # 추가 명령어
            y = int(commands[i+1]) # 추가 개수 y
            s = list(map(int, commands[i+2:i+2+y])) # 추가할 숫자들 리스트 형태
            cmd.append(('A', y, s)) # (명령어, y, s) 형태로 변환 
            i += 2 + y # 인덱스 이동시켜 다음 명령 확인
        
        # D에 해당하는 명령어 모음
        elif commands[i] == 'D': # 삭제 명령어
            x = int(commands[i+1]) # 삭제 시작 위치 x
            y = int(commands[i+2]) # 삭제할 숫자 개수 y
            cmd.append(('D', x, y)) # (명령어, x, y) 형태로 변환 
            i += 3 # 인덱스 이동시켜 다음 명령 확인

    # 각 명령어 실행     
    for c in cmd:
        
        if c[0] == 'I':
            x, y, s = c[1:] # 맨 첫번째 인덱스를 제외한 나머지 ex: (3, 4, [1, 2, 3 ,4]) 형태
            for j in range(y):
                origin.insert(x+j, s[j])
        elif c[0] == 'A':
            y , s = c[1:] 
            for j in range(y):
                origin.append(s[j]) 
        elif c[0] == 'D':
            x, y = c[1], c[2] 
            for j in range(y):
                origin.pop(x)

    print(f"#{tc} {' '.join(map(str, origin[:10]))}")

            

    


