# 진용이네 주차 타워 문제 - 시뮬레이션 문제

# 부지런한 진용이는 정문 앞에서 유료 주차장 운영하고 있다. 이 주차장은 1 부터 n 까지 번호가 매겨진 n 개의 주차 공간을 가지고 있다.
# 매일 아침 모든 주차 공간이 비어 있는 상태에서 영업을 시작하며, 다음과 같은 방식으로 운영된다.

# 차가 주차장에 도착하면, 진용이는 비어있는 주차 공간이 있는지 검사한다.
 
# 비어있는 공간이 없다면, 빈 공간이 생길 때까지 차량을 입구에서 기다리게 한다.
 
# 빈 주차 공간이 있으면 진용이는 곧바로 주차를 시키며, 주차 가능한 공간 중 번호가 가장 작은 주차 공간에 주차하도록 한다.
 
# 만약 주차를 기다리는 차량이 여러 대라면, 입구의 대기장소에서 자기 차례를 기다려야 한다. 운전자들은 예의가 바르기 때문에 새치기를 하지 않는다.
 
# 주차요금은 차량의 무게와 주차 공간마다 따로 책정된 단위 무게당 금액을 곱한 가격이다. 진용이네 주차장에서는 종일 이용권만을 판매하기 때문에 이용시간은 고려하지 않는다.
 
# 진용이는 오늘 주차장을 이용할 m 대의 차량들이 들어오고 나가는 순서를 알고 있다.
# 진용이의 주차장이 오늘 하루 벌어들일 총 수입을 계산하는 프로그램을 작성하라.
 
# [입력]

# 첫 번째 줄에 테스트 케이스의 수 TC 가 주어진다.
# 이후 TC 개의 테스트 케이스가 새 줄로 구분되어 주어진다.
# 각 테스트 케이스는 다음과 같이 구성되어 있다.

# 첫 번째 줄에 자연수  n 과  m 이 주어진다. (1 ≤ n  ≤ 100, 1 ≤ m  ≤ 2000)
# n 개의 줄에 i 번째 주차 공간의 단위 무게당 요금 Ri 가 정수로 주어진다. (1 ≤ Ri  ≤ 100)
# m 개의 줄에 차량 i 의 무게 Wi 가 정수로 주어진다. 차량번호 i 와 차량의 도착 순서는 아무런 관계가 없다. (1 ≤ Wi  ≤ 10000)
# 이후  2m 개의 줄에 차량들의 주차장 출입 순서가 하나의 정수  x 로 주어진다.
# 주어진 정수 x 가 양수면, x 번 차가 주차장에 들어옴을 뜻한다.
# x 가 음수면, -x 번 차가 주차장을 나감을 뜻한다.

# 주차장에 들어오지 않은 차량이 주차장에서 나가는 경우는 주어지지 않는다.
# 1 번부터 m 번까지 모든 차량은 정확하게 한 번씩 주차장에 들어오고, 한 번씩 주차장에서 나간다.
# 또한 입구에서 대기 중인 차량이 주차를 하지 못하고 그냥 돌아가는 경우는 없다.

# [출력]

# 각 테스트 케이스마다 ‘#t ’(t 는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 진용이가 오늘 하룻동안 벌어들일 수입을 출력하라.

# 입력
# 2 // 테스트 케이스 개수 TC = 2
# 3 4  // 첫 번째 테스트 케이스 n = 3,  m = 4
# 2    // 단위 무게당 요금 R_i = {2, 3, 5}
# 3    
# 5
# 2    // 차량의 무게 W_i = {2, 1, 3, 8}
# 1
# 3
# 8
# 3    // i = 3 인 차량이 들어옴
# 2    // i = 2 인 차량이 들어옴
# -3   // i = 3 인 차량이 나감
# 1    // i = 1 인 차량이 들어옴
# 4    // i = 4 인 차량이 들어옴
# -4   // i = 4 인 차량이 나감
# -2   // i = 2 인 차량이 나감
# -1   // i = 1 인 차량이 나감
# 2 4  // 두 번째 테스트 케이스 n = 2,  m = 4
# 5   // 단위 무게당 요금 R_i = {5, 2}
# 2
# 100  // 차량의 무게 W_i = {100, 500, 1000, 2000}
# 500
# 1000
# 2000
# 3   // i = 3 인 차량이 들어옴
# 1   // i = 1 인 차량이 들어옴
# 2  // i = 2 인 차량이 들어옴
# 4   // i = 4 인 차량이 들어옴
# -1   // i = 1 인 차량이 나감
# -3  // i = 3 인 차량이 나감
# -2  // i = 2 인 차량이 나감
# -4   // i = 4 인 차량이 나감
	

# 출력
# #1 53  // 첫 번째 테스트 케이스 결과
# #2 16200	 // 두 번째 테스트

T = int(input())

for tc in range(1, T+1):

    n, m = map(int, input().split())

    # 주차 공간을 나타내는 배열
    # 차량번호, 무게, 단위 요금 저장
    spots = [(0,0,0) for _ in range(n)]

    # 단위 무게 요금
    R_i = [int(input()) for _ in range(n)]

    # 차량 무게 요금
    W_i = [int(input()) for _ in range(m)]
    
    # 차량 입출차 정보
    cars_logs = [int(input()) for _ in range(m*2)]

    # 차량 대기 큐
    cars_queue = []

    # 수입(값)
    income = 0

    # 차량 입출차 정보 길이만큼 반복문 돌면서 나가는 차량인지 들어오는 차량인지 판단

    for i in range(m*2):
        if cars_logs[i] > 0: # 양수일 경우 차량이 들어온 경우
            # 해당 차량 번호의 무게를 추출
            w = W_i[cars_logs[i]- 1]

            # 빈 주차 공간이 있는지 확인
            if (0,0,0) in spots:
                # 해당 주차 공간의 인덱스 추출
                idx = spots.index((0,0,0))
                # 비어있는 인덱스에 해당하는 단위 무게 요금과 차량 무게 요금을 곱한 값을 수입 더한다.
                income += w * R_i[idx]
                # 해당 스팟에 정보 갱신
                spots[idx] = (cars_logs[i], w, R_i[idx])
            
            # 비어 있는 주차 공간이 아닌 경우
            # 차량 대기열에 추가 
            else:
                cars_queue.append(cars_logs[i])

        else: # 차량이 나가는 경우
            # 반복문으로 해당 차량 인덱스의 스팟을 빈공간으로 초기화
            for j in range(n):
                # 주차되어 있는 차량 번호가 i번째 cars_log 의 절대 값과 같은 경우
                if spots[j][0] == abs(cars_logs[i]):
                    spots[j] = (0,0,0) # 초기화 후 종료 
                    break

            # 입구 대기열에 차량이 있는 경우    
            if cars_queue:
                w = W_i[cars_queue[0] - 1]  # 해당 차량 번호의 무게 추출
                # 주차공간이 있는 경우
                idx = spots.index((0,0,0))
                income += w * R_i[idx] # 수익 계산 
                spots[idx] = (cars_queue[0], w, R_i[idx]) # 정보 갱신
                # 입구 대기열에서 차량 번호 제거
                cars_queue.pop(0)
            
    print(f"#{tc} {income}")                


            




