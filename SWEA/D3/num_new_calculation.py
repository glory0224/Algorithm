# 수의 새로운 연산 - (구현 + 수학)

# 2차원 평면 제 1사분면 위의 격자점 (x,y)에 위 그림과 같이 대각선 순서로 점에 수를 붙인다.

# 점 (x,y)에 할당된 수는 #(x,y)로 나타낸다.

# 예를 들어 #(1,1) = 1, #(2,1)=3, #(2,2) = 5, #(4,4) = 25이다.

# 반대로 수 p가 할당된 점을 &(p)로 나타낸다.

# 예를 들어 &(1) = (1,1), &(3) = (2,1), &(5) = (2,2), &(25) = (4,4)이다.

# 두 점에 대해서 덧셈을 정의한다. 점 (x,y)와 점 (z,w)를 더하면 점 (x+z, y+w)가 된다.

# 즉, (x,y) + (z,w) = (x+z, y+w)로 정의한다.

# 우리가 해야 할 일은 수와 수에 대한 새로운 연산 ★를 구현하는 것으로, p★q는 #(&(p)+&(q))으로 나타난다.

# 예를 들어, &(1)=(1,1), &(5) = (2,2)이므로, 1★5 = #(&(1)+&(5)) = #((1,1)+(2,2)) = #(3,3) = 13이 된다.


# [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

# 각 테스트 케이스의 첫 번째 줄에는 두 정수 p,q(1 ≤ p, q ≤ 10,000)가 주어진다.


# [출력]

# 각 테스트 케이스마다 ‘#t’(t는 테스트 케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 각 테스트 케이스마다 p★q의 값을 출력한다.


# 입력
# 2
# 1 5
# 3 9

# 출력
# #1 13
# #2 26

# 딕셔너리로 좌표와 값을 각각 저장하는 방식으로 풀이

# 값에 대한 좌표 저장, 좌표에 대한 값을 저장하는 각각의 딕셔너리 변수 생성

dct = {}
reverse_dct = {}

# 시작 좌표 선언

i, j = 1, 1

# 10000까지의 숫자를 저장할 때 그 크기를 어떻게 정할 것인가? 4배 크기의 삼각형

# 그 범위만큼 for문 돌리면서 해당 값 - 좌표 저장, 해당 좌표 - 값 저장 반복

for n in range(1, 50000):
    dct[n] = (i, j) # 해당 값에 좌표 저장
    reverse_dct[(i, j)] = n # 해당 좌표에 값 저장

    # 왼쪽에서 오른쪽, 대각선 방향으로 값이 1씩 증가
    i, j = i-1 , j+1
    # i가 1보다 작아지는 경우
    if i < 1:
        i, j  = j, 1


# p , q 를 입력 받고 좌표로 변환

T = int(input())

for tc in range(1, T+1):
    p, q = map(int, input().split())

    

    pi, pj = dct[p]
    qi, qj = dct[q]

    # 해당 좌표를 각각 더해주고 그 좌표에 해당하는 값을 변환
    answer = reverse_dct[(pi+qi, pj+qj)]

    # 정답 출력
    print(f"#{tc} {answer}")


