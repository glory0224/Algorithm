# 화섭이의 정수 나열 

# 화섭이는 다음과 같은 흥미로운 추측에 대해 들었다.

# “모든 정수는 π = 3.14159265…의 어떤 연속한 부분으로 나타난다.”

# 화섭이는 π에 대해 이것을 테스트해 보기는 힘들다고 생각했고, 그냥 유한한 정수열에 대해서 위처럼 연속한 부분을 끊어내어 보았다.

# 예를 들면 “3 0 1”같은 정수열로는 3, 0, 1, 30, 301을 만들 수 있다.

# 화섭이는 주어진 정수열로 만들 수 없으면서 가장 작은 정수가 무엇인지 궁금해졌다.

# 이를 구하는 프로그램을 작성하라. 위의 예에서는 0, 1은 나타나지만 2는 나타나지 않으므로 2가 답이 된다.

# 두 번째 테스트케이스를 예로 들면,

# 위 그림과 같이 0부터 11까지의 정수는 만들 수 있으나 12를 만들 수 없다. 그러므로 12가 답이 된다.


# [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

# 각 테스트 케이스의 첫 번째 줄에는 N(1 ≤ N ≤ 103)이 주어진다.

# 다음으로는 N개의 정수 d1, d2, …, dN (0 ≤ di ≤ 9)이 순서대로 주어진다.

# d들은 공백 하나 또는 줄바꿈으로 구분되어 있다.

# [출력]

# 각 테스트 케이스마다 만들어낼 수 없는 가장 작은 정수를 출력한다.

# 입력
# 6
# 3
# 3 0 1
# 11
# 9 8 7 6 5 4 3 2 1 1 0
# 10
# 9 0 8 7 6 5 4 3 2 1
# 100
# 3 6 7 5 3 5 6 2 9 1 2 7 0 9 3 6 0 6 2 6
# 1 8 7 9 2 0 2 3 7 5 9 2 2 8 9 7 3 6 1 2
# 9 3 1 9 4 7 8 4 5 0 3 6 1 0 6 3 2 0 6 1
# 5 5 4 7 6 5 6 9 3 7 4 5 2 5 4 7 4 4 3 0
# 7 8 6 8 8 4 3 1 4 9 2 0 6 8 9 2 6 6 4 9
# 100
# 7 2 7 5 4 7 4 4 5 8 1 5 7 7 0 5 6 2 0 4
# 3 4 1 1 0 6 1 6 6 2 1 7 9 2 4 6 9 3 6 2
# 8 0 5 9 7 6 3 1 4 9 1 9 1 2 6 4 2 9 7 8
# 3 9 5 5 2 3 3 8 4 0 6 8 2 5 5 0 6 7 1 8
# 5 1 4 8 1 3 7 3 3 5 3 0 6 0 6 5 3 2 2 2
# 1
# 3

# 출력
# #1 2
# #2 12
# #3 10
# #4 11
# #5 86
# #6 0

# 1. 입력 값을 문자열 타입 한줄로 N의 횟수만큼 입력 받는다.

# 2. 카운트를 증가할 변수와 답을 출력할 변수를 생성하고 1부터 증가하면서 해당 정수가 입력 받은 문자열 안에 포함되어 있는지 확인한다.

# 3. 만약 포함되어 있지 않다면, 그것은 포함되지 않은 가장 작은 정수이므로 출력한다. 

T = int(input())

for tc in range(1, T+1):
    N = int(input())

    # 문자열 한 줄로 이어서 넣어줄 변수 선언
    num_list = ''

    while True:
        num_list += ''.join(map(str, input().split())) # 입력받는 숫자를 문자열 타입으로 한줄씩 이어 붙여준다.
        # print(num_list)
        if len(num_list) == N:
            break
    
    increase = 0
    answer = 0

    # 포함되어 있지 않는 경우, 제일 작은 정수 
    while True:
        if str(increase) not in num_list:
            answer = increase
            break

        increase += 1
    
    print(f"#{tc} {answer}")