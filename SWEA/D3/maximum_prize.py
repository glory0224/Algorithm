# 최대 상금 문제 

# 퀴즈 대회에 참가해서 우승을 하게 되면 보너스 상금을 획득할 수 있는 기회를 부여받는다.

# 우승자는 주어진 숫자판들 중에 두 개를 선택에서 정해진 횟수만큼 서로의 자리를 위치를 교환할 수 있다.

# 예를 들어, 다음 그림과 3, 2, 8, 8, 8 의 5개의 숫자판들이 주어지고 교환 횟수는 2회라고 하자.

# 교환전>

# 처음에는 첫번째 숫자판의 3과 네 번째 숫자판의 8을 교환해서 8, 2, 8, 3, 8이 되었다.
 

# 다음으로, 두 번째 숫자판 2와 마지막에 있는 8을 교환해서 8, 8, 8, 3, 2이 되었다.



# 정해진 횟수만큼 교환이 끝나면 숫자판의 위치에 부여된 가중치에 의해 상금이 계산된다.

# 숫자판의 오른쪽 끝에서부터 1원이고 왼쪽으로 한자리씩 갈수록 10의 배수만큼 커진다.

# 위의 예에서와 같이 최종적으로 숫자판들이 8,8,8,3,2의 순서가 되면 88832원의 보너스 상금을 획득한다.

# 여기서 주의할 것은 반드시 횟수만큼 교환이 이루어져야 하고 동일한 위치의 교환이 중복되어도 된다.

# 다음과 같은 경우 1회의 교환 횟수가 주어졌을 때 반드시 1회 교환을 수행하므로 결과값은 49가 된다.



# 94의 경우 2회 교환하게 되면 원래의 94가 된다.

# 정해진 횟수만큼 숫자판을 교환했을 때 받을 수 있는 가장 큰 금액을 계산해보자.

# [입력]

# 가장 첫 줄은 전체 테스트 케이스의 수이다.

# 최대 10개의 테스트 케이스가 표준 입력을 통하여 주어진다.

# 각 테스트 케이스에는 숫자판의 정보와 교환 횟수가 주어진다.

# 숫자판의 정보는 정수형 숫자로 주어지고 최대 자릿수는 6자리이며, 최대 교환 횟수는 10번이다.

# [출력]

# 각 테스트 케이스마다, 첫 줄에는 “#C”를 출력해야 하는데 C는 케이스 번호이다.

# 같은 줄에 빈 칸을 하나 사이에 두고 교환 후 받을 수 있는 가장 큰 금액을 출력한다.

def change(numbers, cnt):
    global result # 전역 변수 result를 사용하기 위해 global 키워드 사용

    temp = ''

    for n in numbers:
        temp += n # 리스트에 있는 숫자들을 하나의 문자열로 합친다.
    
    if int(temp) in result[cnt]: # 현재 교환 횟수에서 이전에 계산한 값이 이미 있으면 return 
        return
    else:
        result[cnt].append(int(temp)) # 현재 교환 횟수에서 계산한 값을 결과 리스트에 추가한다.

    if cnt == 0: # 교환 횟수가 0이면 return
        return
    
    n = len(numbers)

    for i in range(n):
        for j in range(i+1, n):
            numbers[i], numbers[j] = numbers[j], numbers[i] # 두 숫자판의 위치를 바꿈

            change(numbers, cnt - 1) # 위치를 바꾼 뒤, 남은 교환 횟수에 대해서 재귀 호출

            numbers[i], numbers[j] = numbers[j], numbers[i] # 재귀 호출이 끝나면 다시 두 숫자판의 위치를 바꿈




T = int(input())

for tc in range(1, T+1):
    num, cnt = input().split()

    numbers = list(num) # 숫자판을 리스트로 변환
    result = [[] for _ in range(int(cnt)+1)] # 교환 횟수에 따른 결과를 저장할 리스트 생성
    
    change(numbers, int(cnt))

    #print('#{} {}'.format(tc, max(result[0]))) 

    print(f"#{tc} {max(result[0])}") # 최종적으로 계산한 값 중에서 가장 큰 값을 출력


