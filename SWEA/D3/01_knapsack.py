# 0/1 Knapsack - 대표적인 dp 문제

# 백트래킹으로 접근할수도 있으나 N의 범위가 20 내외가 아니라서 재귀로 하면 에러 발생 가능성이 높다. 그래서 dp 방식으로 접근하는 것이 좋다. 

# 민수에게는 1번부터 N번까지의 번호가 부여된 N(1≤N≤100)개의 물건과 최대 K(1≤K≤1000) 부피만큼을 넣을 수 있는 가방이 있다.

# 1번 물건부터 N번 물건 각각은 부피  Vi와 가치 Ci 를 가지고 있다. (1≤Vi, Ci≤100)

# 민수는 물건들 중 몇 개를 선택하여 가방에 넣어서 그 가치의 합을 최대화하려고 한다.

# 단, 선택한 물건들의 부피 합이 K 이하여야 한다.

# 민수가 가방에 담을 수 있는 최대 가치를 계산하자.

# [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

# 각 테스트 케이스의 첫째 줄에 물건의 개수와 가방의 부피인 N K가 주어진다.

# 다음 N개의 줄에 걸쳐서 i번 물건의 정보를 나타내는 부피  Vi와 가치 Ci가 주어진다.

# [출력]

# 각 테스트 케이스마다 가방에 담을 수 있는 최대 가치를 출력한다.

# 입력
# 1
# 4 5
# 1 2
# 3 2
# 4 4
# 2 3

# 출력
# #1 6

T = int(input())

for tc in range(1, T+1):
    N, K = map(int, input().split())

    # 입력 부피 최소가 1이기 때문에 0에 해당하는 배열 추가로 생성 
    items = [(0, 0)] + [tuple(map(int, input().split())) for _ in range(N)]

    # N과 K에 해당하는 dp 테이블 생성
    dp = [[0] * (K+1) for _ in range(N+1)]
    
    for i in range(1, N+1):
        for j in range(1, K+1):
            # 해당 부피보다 크지 않을 때
            if items[i][0] <= j:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - items[i][0]] + items[i][1])
            # 해당 부피보다 큰 경우 이전에 있던 최대 값 추가
            else:
                dp[i][j] = dp[i-1][j]
    
    print(f"#{tc} {dp[N][K]}")


