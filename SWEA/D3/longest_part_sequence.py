# 최장 증가 부분 수열

# 주어진 두 수열의 최장 증가 부분 수열(Longest Increasing Subsequence)의 길이를 계산하는 프로그램을 작성하시오.

# 수열 { A1, A2, ... , AN }의 최장 증가 부분 수열 B는 다음과 같이 정의된다.

# { B1, B2, ... , BK }에서 0≤K≤N, B1 < B2 < ... < BK이고,

# AB1 ≤ AB2 ≤ ... ≤ ABK인 최대 K로 구성된 수열이다.

# 예를 들어, 수열이 { 1, 3, 2, 5, 4, 7 } 이라면, 최장 부분 증가 수열의 길이는 4가 된다.

# [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

# 각 테스트 케이스의 첫째 줄에는 수열의 길이 N(1≤N≤1,000)이 주어진다. 

# 둘째 줄에는 수열의 원소 N개가 공백을 사이에 두고 순서대로 주어진다.

# 각 수열의 원소는 1 이상 231-1 이하의 자연수이다.

# [출력]

# 각 테스트 케이스마다 ‘#T’(T는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 최대 증가 부분 수열의 길이를 출력한다.

# 입력
# 2
# 5
# 1 3 2 5 4 
# 6
# 4 2 3 1 5 6

# 출력
# #1 3
# #2 4

T = int(input())

for tc in range(1, T+1):

    N = int(input())

    seq = list(map(int, input().split()))
    # dp 테이블
    dp = [0] * N

    for i in range(N): # N 길이 만큼 돌면서
        # i 인덱스 전까지의 범위를 돈다.
        for j in range(i):
            # 기준인 seq[i]와 비교할 수 seq[j]를 비교하고 기준 dp[i]와 비교 dp[j]를 비교한다.
            # 증가하는 수이기 때문에 기준이 더 커야함
            # dp는 이전 비교 수보다 작아야 이전 수의 값을 이어서 가져올 수 있다. 
            if seq[i] > seq[j] and dp[i] < dp[j]:
                dp[i] = dp[j]

        dp[i] += 1  # 확인했다면 그 값이 최소 길이이거나 더 긴 길이일 수 있기 때문에 dp[i] + 1 처리를 해준다. 
        # i = 0: dp[0] = 1 (1)
        # i = 1: dp[1] = 2 (1, 3)
        # i = 2: dp[2] = 1 (2)
        # i = 3: dp[3] = 3 (1, 3, 5)
        # i = 4: dp[4] = 2 (1, 3, 4)

    print(f"#{tc} {max(dp)}")


        



