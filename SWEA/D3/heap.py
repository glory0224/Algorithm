# 힙 문제 

# 최대 힙

# 힙(Heap)은 최댓값 혹은 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 자료구조이다.

# 완전이진트리(Complete binary tree)를 기본으로 한 자료구조로서 다음과 같은 힙 속성(property)을 만족한다.

# - A가 B의 부모노드(parent node) 이면, A의 키(key)값과 B의 키값 사이에는 항상 일정한 대소관계가 성립한다.

# 키값의 대소관계는 오로지 부모노드와 자식노드 간에만 성립하며, 형제노드 사이에서는 일정한 대소관계가 정해지지 않는다.

# 부모노드의 키값이 자식노드의 키값보다 항상 크거나 같은 힙을 '최대 힙', 부모노드의 키값이 자식노드의 키값보다 항상 작거나 같은 힙을 '최소 힙'이라고 부른다.

# 힙의 루트노드(root node)는 힙을 구성하는 노드의 키값 중 최댓값 혹은 최솟값을 가지게 된다.

# 본 문제에서는 최대 힙(max heap)을 올바르게 구현하였는지 확인할 수 있다.

# 초기에 최대 힙이 비어있을 때에 다음의 2가지 연산을 수행하는 프로그램을 작성하자.

# 연산 1. 자연수 x를 삽입

# 연산 2. 최대 힙의 루트 노드의 키값을 출력하고, 해당 노드를 삭제

# 예를 들어, 쿼리가 순서대로 다음과 같이 5개가 주어졌다고 가정해보자.

# 1. 연산 1 - 3을 삽입

# 2. 연산 1 - 5를 삽입

# 3. 연산 2 - 최댓값 출력 후 해당 키값 삭제

# 4. 연산 1 - 1을 삽입

# 5. 연산 2 - 최댓값 출력 후 해당 키값 삭제

# 3번째 연산을 수행할 때를 기준으로 최대 키값은 5이기 때문에 5가 출력되고, 5는 삭제되기 때문에 최대 힙에는 3만 남게 된다.

# 5번째 연산을 수행할 때를 기준으로 최대 키값은 3이기 때문에 3이 출력되고, 3은 삭제되기 때문에 최대 힙에는 1만 남게 된다.

# 만약 가장 큰 키값이 여러 개일 경우에는, 삭제할 때에 그 키값을 가지는 노드들 전부가 삭제되는 것이 아니라, 루트 노드 단 하나만 삭제됨에 주의한다.

# [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

# 각 테스트 케이스마다 첫째 줄에 수행해야하는 연산의 수를 나타내는 자연수 N(1≤N≤105)이 주어진다. 

# 둘째 줄부터 N개의 줄에 걸쳐서 순서대로 수행해야하는 연산에 대한 정보가 주어진다.

# 연산 1을 수행해야 한다면 2개의 자연수 '1 x'가 주어지며, x(1≤x≤109)를 최대 힙에 추가하는 연산임을 의미한다.

# 연산 2를 수행해야 한다면 1개의 자연수 '2'가 주어지며, 현재 최대 힙의 루트 노드의 키값을 출력하고 해당 노드를 삭제하는 연산임을 의미한다.

# [출력]

# 각 테스트 케이스마다 첫째 줄에 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 연산 2의 결과들을 공백 하나를 사이에 두고 순서대로 출력한다.

# 만약, 연산 2를 수행해야 하는데 힙에 원소가 없어서 출력해야 할 최대 키값이 존재하지 않는다면 -1을 출력한다.

# 입력
# 2
# 3
# 1 1
# 2
# 2
# 5
# 1 3
# 1 5
# 2
# 1 1
# 2

# 출력
# #1 1 -1
# #2 5 3


# heapq 라이브러리 사용

import heapq

T = int(input())

for tc in range(1, T+1):
    N = int(input())

    commands = [input().split() for _ in range(N)]

    # 힙 리스트 생성
    heap = []

    # 값을 모아서 출력할 리스트 변수
    result = []

    # commands에서 해당 명령어 구분하고 명령에 따라 heap 리스트에 추가
    for cmd in commands:
        if cmd[0] == '1':
            heapq.heappush(heap, -int(cmd[1])) # 값을 음수로 바꿔 최대값을 구한다. 왜냐하면, 파이썬의 heapq 모듈은 최소힙만 제공하기 때문
        elif cmd[0] == '2':
            # 뽑기 전에 힙 자료구조에 값이 있는지 체크 
            if heap:
                max_value = -heapq.heappop(heap) # 최대값을 구하기 위해 다시 음수로 바꾼다.
                result.append(max_value)
            else:
                result.append(-1)
    
    print(f"#{tc} {' '.join(map(str, result))}")
    
    


