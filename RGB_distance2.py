# 백준 17404번 RGB 거리 2
# RGB 거리 문제 응용해보기

# 1번 집과 N번 집이 같은 색이 되면 안된다. 

# 1번 집이 특정 색깔일 때 N번 집의 색깔 수 

# 빨강, 초록 | 빨강 , 파랑
# 초록, 빨강 | 초록 , 파랑
# 파랑, 빨강 | 빨강 , 초록

# 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다.

# 이 문제는 색깔을 정해놔야한다. 색깔을 정해놓고 간다는건 그 색깔 값 외에는 값을 모두 일정하게 준다는 것인데 이 때 0으로 일정하게 채우는 경우와 엄청 큰 수로 채우는 경우 두가지로 나눈다.

# dp 식 min(dp[j-1][1], dp[j-1][2]에 0,1,2 인덱스에 '0'을 넣게 되면 min 함수에 계속 걸리게 되면서 중간에 값이 변하게 된다.
# 하지만 0,1,2 인덱스에 큰 값을 넣으면 값이 0으로 초기화 되지 않고 최소값의 범위를 이어나갈 수 있다.  

INF = 2147000000  
n = int(input())
rgb = []
ans = INF
for _ in range(n):
    rgb.append(list(map(int, input().split())))

for i in range(3):
    # dp[i][0] = 2147000000, dp[i][1] = 2147000000, dp[i][2] = 2147000000 큰 값을 미리 넣는다. n = 3 -> [[2147000000, 2147000000, 2147000000], [2147000000, 2147000000, 2147000000], [2147000000, 2147000000, 2147000000]]
    dp = [[INF, INF, INF] for _ in range(n)] 
    # dp[0][0] = rgb[0][0] 지금이 빨간색의 값이라고 가정한다면 26 넣어준다. [26, 2147000000, 2147000000]
    # 이렇게 되면 문제에서 제시한 것 같이 1번째 색깔은 2번과 N번(3)과 같지 않아야 한다는 조건에 맞다. 
    dp[0][i] = rgb[0][i]
    
    # dp 방식으로 최솟값 구하기 
    for j in range(1, n):
        dp[j][0] = rgb[j][0] + min(dp[j-1][1], dp[j-1][2]) # i = 0, j = 1 min(dp[j-1][1], dp[j-1][2]) -> 2147000000 , rgb[1][0] + 2147000000 -> 같은 색깔의 비용이 마지막 dp[2][0], dp[2][1], dp[2][2]를 구할 때 min에 의해서 계산되지 않는다.
        dp[j][1] = rgb[j][1] + min(dp[j-1][0], dp[j-1][2]) # i = 1, j = 1 min(dp[j-1][1], dp[j-1][2]) -> 2147000000 , rgb[1][1] + 2147000000 -> 같은 색깔의 비용이 마지막 dp[2][0], dp[2][1], dp[2][2]를 구할 때 min에 의해서 계산되지 않는다.
        dp[j][2] = rgb[j][2] + min(dp[j-1][0], dp[j-1][1]) # i = 2, j = 1 min(dp[j-1][1], dp[j-1][2]) -> 2147000000 , rgb[1][2] + 2147000000 -> 같은 색깔의 비용이 마지막 dp[2][0], dp[2][1], dp[2][2]를 구할 때 min에 의해서 계산되지 않는다.

    for j in range(3):
        if i != j:
            ans = min(ans, dp[-1][j]) # dp[2][j] 값을 비교하면서 최소 값 계산 
            #print(ans)
print(ans)